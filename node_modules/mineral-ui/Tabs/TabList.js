"use strict";

exports.__esModule = true;
exports.default = void 0;

var _core = require("@emotion/core");

var _react = _interopRequireWildcard(require("react"));

var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _EventListener = _interopRequireDefault(require("../EventListener"));

var _IconChevronLeft = _interopRequireDefault(require("../Icon/IconChevronLeft"));

var _IconChevronRight = _interopRequireDefault(require("../Icon/IconChevronRight"));

var _IconExpandLess = _interopRequireDefault(require("../Icon/IconExpandLess"));

var _IconExpandMore = _interopRequireDefault(require("../Icon/IconExpandMore"));

var _styled = require("./styled");

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _ref =
/*#__PURE__*/
(0, _core.jsx)(_IconExpandLess.default, null);

var _ref2 =
/*#__PURE__*/
(0, _core.jsx)(_IconChevronLeft.default, null);

var _ref3 =
/*#__PURE__*/
(0, _core.jsx)(_IconExpandMore.default, null);

var _ref4 =
/*#__PURE__*/
(0, _core.jsx)(_IconChevronRight.default, null);

var TabList =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(TabList, _Component);

  function TabList() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "state", {
      scrollable: false
    });

    _defineProperty(_assertThisInitialized(_this), "list", void 0);

    _defineProperty(_assertThisInitialized(_this), "root", void 0);

    _defineProperty(_assertThisInitialized(_this), "setListRef", function (node) {
      _this.list = node;
    });

    _defineProperty(_assertThisInitialized(_this), "setRootRef", function (node) {
      _this.root = node;
    });

    _defineProperty(_assertThisInitialized(_this), "updateScrollable", function () {
      var vertical = _this.props.vertical;
      var listNode = _this.list;
      var rootNode = _this.root;

      if (listNode && rootNode) {
        var dimension = vertical ? 'Height' : 'Width';
        var scrollable = Boolean( // $FlowFixMe - indexer property is missing in HTMLElement
        listNode["scroll" + dimension] > rootNode["client" + dimension]);

        if (_this.state.scrollable !== scrollable) {
          _this.setState({
            scrollable: scrollable
          });
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleWindowResize", (0, _lodash.default)(_this.updateScrollable, 100));

    return _this;
  }

  var _proto = TabList.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateScrollable();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps !== this.props) {
      this.updateScrollable();
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        align = _this$props.align,
        children = _this$props.children,
        onIncrement = _this$props.onIncrement,
        position = _this$props.position,
        role = _this$props.role,
        vertical = _this$props.vertical,
        restProps = _objectWithoutPropertiesLoose(_this$props, ["align", "children", "onIncrement", "position", "role", "vertical"]);

    var scrollable = this.state.scrollable;

    var rootProps = _objectSpread({
      align: align,
      ref: this.setRootRef,
      vertical: vertical
    }, restProps, {
      'aria-label': undefined
    });

    var listProps = {
      align: align,
      'aria-label': restProps['aria-label'],
      count: _react.Children.count(children),
      ref: this.setListRef,
      role: role,
      vertical: vertical
    };
    var content = (0, _core.jsx)(_styled.TabListList, listProps, children);

    if (scrollable) {
      var innerProps = {
        position: position,
        scrollX: !vertical,
        scrollY: vertical,
        vertical: vertical
      };
      content = [(0, _core.jsx)(_styled.TabListIncrementButton, {
        key: "start",
        icon: vertical ? _ref : _ref2,
        onClick: function onClick(event) {
          onIncrement && onIncrement('ArrowLeft', event);
        }
      }), (0, _core.jsx)(_styled.TabListInner, _extends({
        key: "inner"
      }, innerProps), content), (0, _core.jsx)(_styled.TabListIncrementButton, {
        key: "end",
        icon: vertical ? _ref3 : _ref4,
        onClick: function onClick(event) {
          onIncrement && onIncrement('ArrowRight', event);
        }
      })];
    }

    return (0, _core.jsx)(_styled.TabListRoot, rootProps, content, (0, _core.jsx)(_EventListener.default, {
      listeners: [{
        event: 'resize',
        handler: this.handleWindowResize,
        target: 'window'
      }]
    }));
  };

  return TabList;
}(_react.Component);

exports.default = TabList;

_defineProperty(TabList, "displayName", 'TabList');

_defineProperty(TabList, "defaultProps", {
  position: _constants.POSITION.top
});