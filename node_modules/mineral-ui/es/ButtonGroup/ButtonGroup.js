import { jsx as ___EmotionJSX } from "@emotion/core";

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { Children, Component, cloneElement } from 'react';
import { setFromArray, toArray } from "../utils/collections";
import { findDeep } from "../utils/children";
import composeEventHandlers from "../utils/composeEventHandlers";
import { MODE } from "./constants";
import { ButtonGroupRoot as Root } from "./styled";
import { buttonGroupPropTypes } from "./propTypes";

// This check is intentionally loose. We cannot do a direct type comparison as
// we want to allow for styled buttons, themed buttons, and buttons inside of
// wrappers like Dropdowns, Popovers, and Tooltips.
// NOTE: We can rely on displayName, without fear of it being mangled, even in
// production, as long as it is set statically on each component
// https://github.com/facebook/react/issues/4915#issuecomment-335803765
var isButtonComponent = function isButtonComponent(element) {
  return element.type && /Button/.test(element.type.displayName);
};

var isItemAtIndexChecked = function isItemAtIndexChecked(checked, index) {
  var isSet = checked instanceof Set;
  var checkedSet = isSet ? checked : setFromArray(toArray(checked)); // $FlowFixMe - Refinement to Set not working

  return checkedSet.has(index);
};

var getDefaultCheckedState = function getDefaultCheckedState(props) {
  var _children = props.children,
      defaultChecked = props.defaultChecked,
      mode = props.mode;
  var children = Children.toArray(_children);

  if (mode && defaultChecked !== undefined) {
    var defaultCheckedArray = toArray(defaultChecked);

    var _checked = mode === MODE.checkbox ? defaultCheckedArray : [defaultCheckedArray[0]];

    return setFromArray(_checked);
  }

  var checked = new Set();
  children.forEach(function (child, index) {
    if (mode === MODE.checkbox) {
      if (child.props.defaultChecked) {
        checked.add(index);
      }
    } else if (mode === MODE.radio) {
      var selectedChild = children.find(function (child) {
        return child.props.defaultChecked;
      });

      var _index = children.indexOf(selectedChild);

      if (_index !== -1) {
        checked.add(_index);
      }
    }
  });
  return checked;
};

var ButtonGroup =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(ButtonGroup, _Component);

  function ButtonGroup() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "state", {
      checked: getDefaultCheckedState(_this.props)
    });

    _defineProperty(_assertThisInitialized(_this), "handleClick", function (index, event) {
      var mode = _this.props.mode;

      if (!mode) {
        return _this.clickActions(event, false);
      }

      event.persist();
      var target = event.currentTarget;

      if (_this.isControlled('checked')) {
        _this.clickActions(event, true);
      } else {
        var changed;

        _this.setState(function (prevState) {
          var checked;

          if (mode === MODE.checkbox) {
            changed = true;
            checked = prevState.checked;
            var dataIndex = parseInt(target.getAttribute('data-index'));
            checked.has(dataIndex) ? checked.delete(dataIndex) : checked.add(dataIndex);
          } else {
            checked = setFromArray([index]);
            changed = isItemAtIndexChecked(checked, index) !== isItemAtIndexChecked(prevState.checked, index);
          }

          return {
            checked: checked
          };
        }, function () {
          _this.clickActions(event, changed);
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "clickActions", function (event, changed) {
      var _this$props = _this.props,
          onChange = _this$props.onChange,
          onClick = _this$props.onClick;
      onClick && onClick(event);
      changed && onChange && onChange(event);
    });

    _defineProperty(_assertThisInitialized(_this), "isControlled", function (prop) {
      return _this.props.hasOwnProperty(prop);
    });

    _defineProperty(_assertThisInitialized(_this), "getControllableValue", function (key) {
      return _this.isControlled(key) ? _this.props[key] : _this.state[key];
    });

    return _this;
  }

  var _proto = ButtonGroup.prototype;

  _proto.render = function render() {
    var _this2 = this;

    var _this$props2 = this.props,
        ignoreChecked = _this$props2.checked,
        children = _this$props2.children,
        disabled = _this$props2.disabled,
        fullWidth = _this$props2.fullWidth,
        mode = _this$props2.mode,
        ignoreOnClick = _this$props2.onClick,
        size = _this$props2.size,
        variant = _this$props2.variant,
        restProps = _objectWithoutPropertiesLoose(_this$props2, ["checked", "children", "disabled", "fullWidth", "mode", "onClick", "size", "variant"]);

    var rootProps = _objectSpread({
      fullWidth: fullWidth,
      role: mode === MODE.radio ? 'radiogroup' : 'group',
      variant: variant
    }, restProps);

    var checked = this.getControllableValue('checked');
    var buttons = Children.map(children, function (child, index) {
      var isToggleable = Boolean(mode);
      var isChecked = isItemAtIndexChecked(checked, index);
      var isButton = isButtonComponent(child);
      var nestedButton = isButton ? undefined : // Must be able to find styled/themed buttons inside of triggers
      findDeep(child.props.children, isButtonComponent);
      return cloneElement(child, _objectSpread({}, isToggleable ? {
        'aria-checked': isChecked
      } : undefined, nestedButton ? {
        children: cloneElement(nestedButton, {
          'data-variant': nestedButton.props.variant,
          variant: nestedButton.props.variant || variant
        })
      } : undefined, {
        'data-index': index
      }, isButton ? {
        'data-variant': child.props.variant
      } : undefined, {
        disabled: disabled || child.props.disabled,
        key: index
      }, isToggleable && isChecked ? {
        primary: true
      } : undefined, {
        onClick: composeEventHandlers(child.props.onClick, _this2.handleClick.bind(null, index))
      }, isToggleable ? {
        role: mode
      } : undefined, {
        size: size
      }, variant && isButton ? {
        variant: child.props.variant || variant
      } : undefined));
    });
    return ___EmotionJSX(Root, rootProps, buttons);
  };

  return ButtonGroup;
}(Component);

_defineProperty(ButtonGroup, "displayName", 'ButtonGroup');

export { ButtonGroup as default };
ButtonGroup.propTypes = process.env.NODE_ENV !== "production" ? buttonGroupPropTypes : {};