import { jsx as ___EmotionJSX } from "@emotion/core";

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React, { Children, cloneElement } from 'react';
import { pxToEm } from "../styles";
import { getPrevNonNull } from "../styles/getResponsiveStyles";
import { withTheme } from 'emotion-theming';
import { ALIGN_ITEMS, DIRECTION, GUTTER_WIDTH, JUSTIFY_CONTENT } from "./constants";
import { FlexRoot as Root } from "./styled";
import { flexPropTypes } from "./propTypes";

var getGutterSize = function getGutterSize(theme, value) {
  return typeof value === 'number' && value !== 0 ? pxToEm(value) : theme["space_inline_" + value] || value;
};

var getIndexedValue = function getIndexedValue(property, index) {
  return property && Array.isArray(property) && index !== undefined ? property[index] : property;
};

var getMarginOrGutter = function getMarginOrGutter(_ref) {
  var gutterWidth = _ref.gutterWidth,
      index = _ref.index,
      margin = _ref.margin,
      marginEnd = _ref.marginEnd,
      marginHorizontal = _ref.marginHorizontal,
      marginStart = _ref.marginStart,
      start = _ref.start,
      theme = _ref.theme;
  return getIndexedValue(start ? marginStart : marginEnd, index) || getIndexedValue(marginHorizontal, index) || getIndexedValue(margin, index) || getGutterSize(theme, gutterWidth);
};

var getMarginProps = function getMarginProps(_ref2) {
  var direction = _ref2.direction,
      gutterWidth = _ref2.gutterWidth,
      theme = _ref2.theme,
      restProps = _objectWithoutPropertiesLoose(_ref2, ["direction", "gutterWidth", "theme"]);

  if (Array.isArray(direction)) {
    return direction.reduce(function (acc, _, index) {
      var value = getPrevNonNull(direction, index);

      if (value === DIRECTION.row || value === DIRECTION['row-reverse']) {
        pushMarginProps(_objectSpread({
          direction: value,
          index: index,
          gutterWidth: gutterWidth,
          props: acc,
          theme: theme
        }, restProps));
      } else {
        pushMarginProps(_objectSpread({
          index: index,
          gutterWidth: 0,
          props: acc,
          theme: theme
        }, restProps));
      }

      return acc;
    }, {
      marginStart: [],
      marginEnd: []
    });
  } else if (direction === DIRECTION.row || direction === DIRECTION['row-reverse']) {
    var _ref3;

    var flip = direction === DIRECTION['row-reverse'];
    var marginProperty = flip ? 'marginStart' : 'marginEnd';
    return _ref3 = {}, _ref3[marginProperty] = getMarginOrGutter(_objectSpread({}, restProps, {
      gutterWidth: gutterWidth,
      start: flip,
      theme: theme
    })), _ref3;
  }
};

var pushMarginProps = function pushMarginProps(_ref4) {
  var direction = _ref4.direction,
      index = _ref4.index,
      gutterWidth = _ref4.gutterWidth,
      props = _ref4.props,
      theme = _ref4.theme,
      restProps = _objectWithoutPropertiesLoose(_ref4, ["direction", "index", "gutterWidth", "props", "theme"]);

  var flip = direction === DIRECTION['row-reverse'];
  props.marginEnd.push(getMarginOrGutter(_objectSpread({}, restProps, {
    gutterWidth: flip ? 0 : gutterWidth,
    index: index,
    theme: theme
  })));
  props.marginStart.push(getMarginOrGutter(_objectSpread({}, restProps, {
    gutterWidth: flip ? gutterWidth : 0,
    index: index,
    start: true,
    theme: theme
  })));
};

var ThemedRoot = withTheme(function (_ref5) {
  var breakpoints = _ref5.breakpoints,
      children = _ref5.children,
      direction = _ref5.direction,
      gutterWidth = _ref5.gutterWidth,
      theme = _ref5.theme,
      restProps = _objectWithoutPropertiesLoose(_ref5, ["breakpoints", "children", "direction", "gutterWidth", "theme"]);

  var rootProps = _objectSpread({
    breakpoints: breakpoints,
    direction: direction,
    gutterWidth: gutterWidth
  }, restProps);

  var flexItems;
  flexItems = Children.map(children, function (child, index) {
    if (child && child.props) {
      var _child$props = child.props,
          propBreakpoints = _child$props.breakpoints,
          restChildProps = _objectWithoutPropertiesLoose(_child$props, ["breakpoints"]);

      var props = {
        breakpoints: propBreakpoints || breakpoints
      };
      var flexItemsCount = Children.count(children);

      if (gutterWidth && index < flexItemsCount - 1) {
        props = _objectSpread({}, props, getMarginProps(_objectSpread({
          direction: direction,
          gutterWidth: gutterWidth,
          theme: theme
        }, restChildProps)));
      }

      return cloneElement(child, props);
    }

    return child;
  });
  return ___EmotionJSX(Root, rootProps, flexItems);
});

var Flex = function Flex(props) {
  return ___EmotionJSX(ThemedRoot, props);
};

Flex.displayName = 'Flex';
var defaultProps = {
  alignItems: ALIGN_ITEMS.stretch,
  direction: DIRECTION.row,
  gutterWidth: GUTTER_WIDTH.md,
  justifyContent: JUSTIFY_CONTENT.start
};
Flex.defaultProps = defaultProps;
Flex.propTypes = process.env.NODE_ENV !== "production" ? flexPropTypes : {};
export default Flex;