import _styled from "@emotion/styled-base";

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import isPropValid from '@emotion/is-prop-valid';
import { rtlTextAlign } from "../utils";
import { componentStyleReset } from "../styles";
import { textTheme } from "./themes";
import { APPEARANCE, HEADING_ELEMENTS, MONOSPACE_ELEMENTS } from "./constants";

var getCommonStyles = function getCommonStyles(as, theme, truncate) {
  var styles = {
    marginBottom: 0,
    marginTop: 0
  };

  if (truncate) {
    styles = _objectSpread({}, styles, {
      // These styles from polished's ellipsis, which we cannot use here
      // because the dynamic width means the output can't be extracted at
      // build time.
      maxWidth: truncate === true ? '100%' : truncate,
      overflow: 'hidden',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      wordWrap: 'normal'
    });
  }

  if (MONOSPACE_ELEMENTS.indexOf(as) !== -1) {
    styles.fontFamily = theme.fontFamily_monospace;
  }

  return styles;
};

export var TextRoot =
/*#__PURE__*/
_styled('p', {
  shouldForwardProp: function shouldForwardProp(prop) {
    return ['color', 'fontWeight'].indexOf(prop) === -1 && isPropValid(prop);
  },
  target: "e19le4zx0"
})(function (_ref) {
  var align = _ref.align,
      propAppearance = _ref.appearance,
      as = _ref.as,
      color = _ref.color,
      defaultAppearance = _ref.defaultAppearance,
      fontWeight = _ref.fontWeight,
      inherit = _ref.inherit,
      noMargins = _ref.noMargins,
      baseTheme = _ref.theme,
      truncate = _ref.truncate;
  var theme = textTheme(baseTheme);

  if (inherit) {
    return getCommonStyles(as, theme, truncate);
  }

  var isHeadingElement = HEADING_ELEMENTS.indexOf(as) !== -1;
  var appearance = propAppearance !== defaultAppearance ? propAppearance : isHeadingElement ? as : undefined;
  var headingAppearance = HEADING_ELEMENTS.indexOf(appearance) !== -1 && appearance;

  if (headingAppearance) {
    theme = _objectSpread({}, theme, {
      Text_color: theme["Text_color_" + headingAppearance],
      Text_fontSize: theme["Text_fontSize_" + headingAppearance],
      Text_fontWeight: theme["Text_fontWeight_" + headingAppearance],
      Text_lineHeight: ['h5', 'h6'].indexOf(headingAppearance) !== -1 ? theme.Text_lineHeight_headingSmall : theme.Text_lineHeight_heading,
      Text_marginBottom: theme.Text_marginBottom_heading
    });
  } else if (appearance === APPEARANCE.mouse) {
    theme = _objectSpread({}, theme, {
      Text_color: theme.Text_color_mouse,
      Text_fontSize: theme.Text_fontSize_mouse
    });
  } else if (appearance === APPEARANCE.prose) {
    theme = _objectSpread({}, theme, {
      Text_fontSize: theme.Text_fontSize_prose
    });
  }

  return _objectSpread({}, componentStyleReset(baseTheme), {
    color: color || theme.Text_color,
    fontSize: parseFloat(theme.Text_fontSize) * parseInt(theme.fontSize_base) + "px",
    fontWeight: function () {
      if (fontWeight && theme["fontWeight_" + fontWeight]) {
        return theme["fontWeight_" + fontWeight];
      } else if (headingAppearance && theme.Text_fontWeight) {
        return theme.Text_fontWeight;
      } else if (isHeadingElement) {
        return fontWeight || theme.fontWeight_regular;
      } else {
        return fontWeight;
      }
    }(),
    lineHeight: theme.Text_lineHeight,
    textAlign: rtlTextAlign(align, theme.direction)
  }, getCommonStyles(as, theme, truncate), {
    // 1 - Not normalized because we actually want `##em` as applied value
    // 2 - Must come after commonStyles
    marginBottom: noMargins ? 0 : theme.Text_marginBottom
  });
});