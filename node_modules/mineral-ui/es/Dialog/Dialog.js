import { jsx as ___EmotionJSX } from "@emotion/core";

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React, { cloneElement, Component } from 'react';
import { canUseDOM } from 'exenv';
import FocusTrap from 'focus-trap-react';
import noScroll from 'no-scroll';
import Transition from 'react-transition-group/Transition';
import { withTheme } from 'emotion-theming';
import { generateId } from "../utils";
import { excludeByType, findByType } from "../utils/children";
import Button from "../Button";
import Portal from "../Portal";
import EventListener from "../EventListener";
import { ACTIONS_SIZE, SIZE } from "./constants";
import { DialogRoot as Root, DialogAnimate, DialogCloseButton, DialogContent, DialogIEWrapper, DialogOverlay } from "./styled";
import { dialogTheme } from "./themes";
import DialogActions from "./DialogActions";
import DialogBody from "./DialogBody";
import DialogFooter from "./DialogFooter";
import DialogHeader from "./DialogHeader";
import DialogTitle from "./DialogTitle";
import { dialogPropTypes } from "./propTypes";
var Animation = withTheme(function (_ref) {
  var children = _ref.children,
      theme = _ref.theme,
      restProps = _objectWithoutPropertiesLoose(_ref, ["children", "theme"]);

  return ___EmotionJSX(Transition, _extends({
    appear: true,
    mountOnEnter: true,
    timeout: parseFloat(dialogTheme(theme).Dialog_transitionDuration),
    unmountOnExit: true
  }, restProps), function (state) {
    return ___EmotionJSX(DialogAnimate, {
      state: state
    }, children);
  });
});

var _ref3 =
/*#__PURE__*/
___EmotionJSX(DialogOverlay, null);

var Dialog =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(Dialog, _Component);

  function Dialog() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "state", {
      isExited: false,
      isExiting: false
    });

    _defineProperty(_assertThisInitialized(_this), "appNodes", void 0);

    _defineProperty(_assertThisInitialized(_this), "id", _this.props.id || "dialog-" + generateId());

    _defineProperty(_assertThisInitialized(_this), "dialogRoot", void 0);

    _defineProperty(_assertThisInitialized(_this), "dialogContent", void 0);

    _defineProperty(_assertThisInitialized(_this), "lastFocusedElement", void 0);

    _defineProperty(_assertThisInitialized(_this), "renderHeader", function () {
      var _this$props = _this.props,
          children = _this$props.children,
          closeButtonLabel = _this$props.closeButtonLabel,
          preventCloseButtonClose = _this$props.preventCloseButtonClose,
          showCloseButton = _this$props.showCloseButton,
          title = _this$props.title,
          variant = _this$props.variant;

      var closeButtonProps = _objectSpread({
        'aria-label': closeButtonLabel
      }, preventCloseButtonClose ? undefined : {
        onClick: _this.close
      }); // prettier-ignore


      var closeButton = showCloseButton ? ___EmotionJSX(DialogCloseButton, closeButtonProps) : undefined;
      var header;
      var titleProps = {
        id: _this.getTitleId(),
        variant: variant
      };

      if (title) {
        header = ___EmotionJSX(DialogHeader, {
          closeButton: closeButton
        }, typeof title === 'string' ? ___EmotionJSX(DialogTitle, titleProps, title) : cloneElement(title, titleProps));
      } else {
        var headerChild = findByType(children, DialogHeader);

        if (headerChild) {
          var headerChildProps = {
            titleProps: titleProps,
            closeButton: headerChild.props.closeButton || closeButton
          };
          header = cloneElement(headerChild, headerChildProps);
        }
      }

      return header;
    });

    _defineProperty(_assertThisInitialized(_this), "renderBody", function () {
      var children = _this.props.children;
      var body;
      var bodyChild = findByType(children, DialogBody);

      if (bodyChild) {
        body = bodyChild;
      } else {
        var bodyChildren = excludeByType(children, [DialogHeader, DialogFooter]);

        if (bodyChildren) {
          body = ___EmotionJSX(DialogBody, null, bodyChildren);
        }
      }

      return body;
    });

    _defineProperty(_assertThisInitialized(_this), "renderFooter", function () {
      var _this$props2 = _this.props,
          actions = _this$props2.actions,
          children = _this$props2.children,
          size = _this$props2.size,
          variant = _this$props2.variant;
      var footer;

      if (actions) {
        var keyedActions = actions.map(function (_ref2, index) {
          var text = _ref2.text,
              buttonSize = _ref2.size,
              restProps = _objectWithoutPropertiesLoose(_ref2, ["text", "size"]);

          var buttonProps = _objectSpread({
            size: buttonSize || (size === ACTIONS_SIZE.large ? ACTIONS_SIZE.large : ACTIONS_SIZE.medium)
          }, restProps);

          return ___EmotionJSX(Button, _extends({}, buttonProps, {
            key: index
          }), text);
        });
        footer = ___EmotionJSX(DialogFooter, null, ___EmotionJSX(DialogActions, {
          variant: variant
        }, keyedActions));
      } else {
        var footerChild = findByType(children, DialogFooter);

        if (footerChild) {
          footer = footerChild;
        }
      }

      return footer;
    });

    _defineProperty(_assertThisInitialized(_this), "getTitleId", function () {
      return _this.id + "-title";
    });

    _defineProperty(_assertThisInitialized(_this), "getContentId", function () {
      return _this.id + "-content";
    });

    _defineProperty(_assertThisInitialized(_this), "setContentRef", function (node) {
      _this.dialogContent = node;
    });

    _defineProperty(_assertThisInitialized(_this), "setRootRef", function (node) {
      _this.dialogRoot = node;
    });

    _defineProperty(_assertThisInitialized(_this), "setLastFocusedElement", function () {
      if (canUseDOM) {
        var _global$document = global.document,
            activeElement = _global$document.activeElement,
            body = _global$document.body;
        _this.lastFocusedElement = activeElement && activeElement.focus ? activeElement : body;
      }
    });

    _defineProperty(_assertThisInitialized(_this), "restoreFocus", function () {
      _this.lastFocusedElement && _this.lastFocusedElement.focus();
    });

    _defineProperty(_assertThisInitialized(_this), "setInitialFocus", function () {
      _this.dialogRoot && _this.dialogRoot.focus();
    });

    _defineProperty(_assertThisInitialized(_this), "open", function () {
      var modeless = _this.props.modeless;

      _this.setLastFocusedElement();

      if (!modeless) {
        _this.setAppNode();

        _this.disableAppNode();

        if (canUseDOM) {
          noScroll.on();
        }
      }

      _this.setState({
        isExited: false
      });
    });

    _defineProperty(_assertThisInitialized(_this), "close", function () {
      _this.handleExiting();
    });

    _defineProperty(_assertThisInitialized(_this), "handleClick", function (event) {
      if (_this.isEventOutsideNode(event, _this.dialogContent)) {
        _this.close();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleDocumentKeydown", function (event) {
      if (event.key.indexOf('Esc') === 0 && !event.defaultPrevented) {
        _this.close();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleEntered", function () {
      !_this.props.disableFocusOnOpen && _this.setInitialFocus();
      _this.props.onOpen && _this.props.onOpen();
    });

    _defineProperty(_assertThisInitialized(_this), "handleExiting", function () {
      _this.setState({
        isExiting: true
      });
    });

    _defineProperty(_assertThisInitialized(_this), "handleExited", function () {
      var _this$props3 = _this.props,
          modeless = _this$props3.modeless,
          onClose = _this$props3.onClose;

      _this.setState({
        isExited: true,
        isExiting: false
      }, function () {
        if (!modeless) {
          if (canUseDOM) {
            noScroll.off();
          }

          _this.enableAppNode();
        }

        _this.restoreFocus();

        onClose && onClose();
      });
    });

    _defineProperty(_assertThisInitialized(_this), "isEventOutsideNode", function (event, node) {
      var target = event.target;
      return node && target instanceof Node && !node.contains(target);
    });

    _defineProperty(_assertThisInitialized(_this), "setAppNode", function () {
      var appSelector = _this.props.appSelector;

      if (appSelector && canUseDOM) {
        _this.appNodes = Array.from(document.querySelectorAll(appSelector));

        if (!_this.appNodes.length) {
          throw new Error("[mineral-ui/Dialog]: Unable to find app node(s) using the appSelector of '" + appSelector + "'.");
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "disableAppNode", function () {
      _this.appNodes && _this.appNodes.forEach(function (node) {
        return node.setAttribute('aria-hidden', 'true');
      });
    });

    _defineProperty(_assertThisInitialized(_this), "enableAppNode", function () {
      _this.appNodes && _this.appNodes.forEach(function (node) {
        return node.removeAttribute('aria-hidden');
      });
    });

    return _this;
  }

  var _proto = Dialog.prototype;

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (!prevProps.isOpen && this.props.isOpen) {
      this.open();
    }
  };

  _proto.render = function render() {
    var _this$props4 = this.props,
        children = _this$props4.children,
        closeOnClickOutside = _this$props4.closeOnClickOutside,
        closeOnEscape = _this$props4.closeOnEscape,
        disableFocusTrap = _this$props4.disableFocusTrap,
        isOpen = _this$props4.isOpen,
        hideOverlay = _this$props4.hideOverlay,
        modeless = _this$props4.modeless,
        ignoreOnClose = _this$props4.onClose,
        ignoreOnOpen = _this$props4.onOpen,
        size = _this$props4.size,
        title = _this$props4.title,
        usePortal = _this$props4.usePortal,
        restProps = _objectWithoutPropertiesLoose(_this$props4, ["children", "closeOnClickOutside", "closeOnEscape", "disableFocusTrap", "isOpen", "hideOverlay", "modeless", "onClose", "onOpen", "size", "title", "usePortal"]);

    var _this$state = this.state,
        isExited = _this$state.isExited,
        isExiting = _this$state.isExiting;

    if (isExited) {
      return null;
    }

    var headerId = this.getTitleId();
    var contentId = this.getContentId();
    var hasBody = findByType(children, DialogBody);
    var hasImmediatleTitle = findByType(children, DialogTitle);
    var hasHeader = title || findByType(children, DialogHeader);

    if (hasBody && hasImmediatleTitle) {
      throw new Error('[mineral-ui/Dialog] You must wrap DialogTitle in DialogHeader');
    }

    if (!hasHeader && !this.props['aria-label']) {
      throw new Error('[mineral-ui/Dialog] You must provide an accessible title via the title prop, the DialogTitle component, or the aria-label prop');
    }

    var rootProps = _objectSpread({
      'aria-labelledby': this.props['aria-label'] ? undefined : hasHeader ? headerId : contentId,
      'aria-modal': !modeless,
      id: this.id,
      ref: this.setRootRef,
      modeless: modeless,
      role: 'dialog',
      tabIndex: '-1'
    }, closeOnClickOutside && !modeless ? {
      onClick: this.handleClick
    } : undefined, restProps);

    var contentProps = {
      id: contentId,
      ref: this.setContentRef,
      role: 'document',
      size: size
    };
    var animationProps = {
      in: isOpen && !isExiting,
      onExiting: this.handleExiting,
      onExited: this.handleExited,
      onEntered: this.handleEntered
    };
    var focusTrapProps = {
      active: !disableFocusTrap && !modeless
    };

    var output = ___EmotionJSX(Animation, animationProps, ___EmotionJSX(FocusTrap, focusTrapProps, ___EmotionJSX(Root, rootProps, !hideOverlay && !modeless && _ref3, ___EmotionJSX(DialogIEWrapper, null, ___EmotionJSX(DialogContent, contentProps, this.renderHeader(), this.renderBody(), this.renderFooter())), closeOnEscape && ___EmotionJSX(EventListener, {
      listeners: [{
        target: 'document',
        event: 'keydown',
        handler: this.handleDocumentKeydown
      }]
    }))));

    return usePortal ? ___EmotionJSX(Portal, null, output) : output;
  };

  return Dialog;
}(Component);

_defineProperty(Dialog, "displayName", 'Dialog');

_defineProperty(Dialog, "defaultProps", {
  closeButtonLabel: 'close',
  closeOnClickOutside: true,
  closeOnEscape: true,
  size: SIZE.medium,
  usePortal: true
});

export { Dialog as default };
Dialog.propTypes = process.env.NODE_ENV !== "production" ? dialogPropTypes : {};