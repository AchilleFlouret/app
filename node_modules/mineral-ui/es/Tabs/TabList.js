import { jsx as ___EmotionJSX } from "@emotion/core";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { Children, Component } from 'react';
import debounce from 'lodash.debounce';
import EventListener from "../EventListener";
import IconChevronLeft from "../Icon/IconChevronLeft";
import IconChevronRight from "../Icon/IconChevronRight";
import IconExpandLess from "../Icon/IconExpandLess";
import IconExpandMore from "../Icon/IconExpandMore";
import { TabListRoot as Root, TabListIncrementButton as IncrementButton, TabListInner as Inner, TabListList as List } from "./styled";
import { POSITION } from "./constants";

var _ref =
/*#__PURE__*/
___EmotionJSX(IconExpandLess, null);

var _ref2 =
/*#__PURE__*/
___EmotionJSX(IconChevronLeft, null);

var _ref3 =
/*#__PURE__*/
___EmotionJSX(IconExpandMore, null);

var _ref4 =
/*#__PURE__*/
___EmotionJSX(IconChevronRight, null);

var TabList =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(TabList, _Component);

  function TabList() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Component.call.apply(_Component, [this].concat(args)) || this;

    _defineProperty(_assertThisInitialized(_this), "state", {
      scrollable: false
    });

    _defineProperty(_assertThisInitialized(_this), "list", void 0);

    _defineProperty(_assertThisInitialized(_this), "root", void 0);

    _defineProperty(_assertThisInitialized(_this), "setListRef", function (node) {
      _this.list = node;
    });

    _defineProperty(_assertThisInitialized(_this), "setRootRef", function (node) {
      _this.root = node;
    });

    _defineProperty(_assertThisInitialized(_this), "updateScrollable", function () {
      var vertical = _this.props.vertical;
      var listNode = _this.list;
      var rootNode = _this.root;

      if (listNode && rootNode) {
        var dimension = vertical ? 'Height' : 'Width';
        var scrollable = Boolean( // $FlowFixMe - indexer property is missing in HTMLElement
        listNode["scroll" + dimension] > rootNode["client" + dimension]);

        if (_this.state.scrollable !== scrollable) {
          _this.setState({
            scrollable: scrollable
          });
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleWindowResize", debounce(_this.updateScrollable, 100));

    return _this;
  }

  var _proto = TabList.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateScrollable();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (prevProps !== this.props) {
      this.updateScrollable();
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        align = _this$props.align,
        children = _this$props.children,
        onIncrement = _this$props.onIncrement,
        position = _this$props.position,
        role = _this$props.role,
        vertical = _this$props.vertical,
        restProps = _objectWithoutPropertiesLoose(_this$props, ["align", "children", "onIncrement", "position", "role", "vertical"]);

    var scrollable = this.state.scrollable;

    var rootProps = _objectSpread({
      align: align,
      ref: this.setRootRef,
      vertical: vertical
    }, restProps, {
      'aria-label': undefined
    });

    var listProps = {
      align: align,
      'aria-label': restProps['aria-label'],
      count: Children.count(children),
      ref: this.setListRef,
      role: role,
      vertical: vertical
    };

    var content = ___EmotionJSX(List, listProps, children);

    if (scrollable) {
      var innerProps = {
        position: position,
        scrollX: !vertical,
        scrollY: vertical,
        vertical: vertical
      };
      content = [___EmotionJSX(IncrementButton, {
        key: "start",
        icon: vertical ? _ref : _ref2,
        onClick: function onClick(event) {
          onIncrement && onIncrement('ArrowLeft', event);
        }
      }), ___EmotionJSX(Inner, _extends({
        key: "inner"
      }, innerProps), content), ___EmotionJSX(IncrementButton, {
        key: "end",
        icon: vertical ? _ref3 : _ref4,
        onClick: function onClick(event) {
          onIncrement && onIncrement('ArrowRight', event);
        }
      })];
    }

    return ___EmotionJSX(Root, rootProps, content, ___EmotionJSX(EventListener, {
      listeners: [{
        event: 'resize',
        handler: this.handleWindowResize,
        target: 'window'
      }]
    }));
  };

  return TabList;
}(Component);

_defineProperty(TabList, "displayName", 'TabList');

_defineProperty(TabList, "defaultProps", {
  position: POSITION.top
});

export { TabList as default };