"use strict";

exports.__esModule = true;
exports.GridItemRoot = exports.GridRoot = void 0;

var _styledBase = _interopRequireDefault(require("@emotion/styled-base"));

var _withProps = _interopRequireDefault(require("recompose/withProps"));

var _styles = require("../styles");

var _Flex = _interopRequireWildcard(require("../Flex"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var GridRoot = (0, _withProps.default)({
  wrap: true
})((
/*#__PURE__*/
0, _styledBase.default)(_Flex.default, {
  shouldForwardProp: function shouldForwardProp(prop) {
    return ['direction', 'inline', 'justifyContent'].indexOf(prop) === -1;
  },
  target: "e1wbdvuc0"
})({
  name: "k008qs",
  styles: "display:flex;"
}));
exports.GridRoot = GridRoot;

var getFlexGrow = function getFlexGrow(value) {
  return value ? 0 : 1;
};

var getWidth = function getWidth(value, columns, gutter) {
  return value ? "calc(" + value / columns * 100 + "% - " + gutter + ")" : 0;
};

var GridItemRoot = (0, _withProps.default)({
  shrink: 0
})((
/*#__PURE__*/
0, _styledBase.default)(_Flex.FlexItem, {
  shouldForwardProp: function shouldForwardProp(prop) {
    return ['alignSelf', 'grow', 'inline', 'span', 'width'].indexOf(prop) === -1;
  },
  target: "e1wbdvuc1"
})(function (_ref) {
  var breakpoints = _ref.breakpoints,
      columns = _ref.columns,
      gutterWidth = _ref.gutterWidth,
      span = _ref.span,
      theme = _ref.theme;
  var gutter = typeof gutterWidth === 'number' ? gutterWidth + "px" : theme["space_inline_" + gutterWidth] || gutterWidth;

  var mapValueToProperty = function mapValueToProperty(property, value) {
    var map = {
      flexGrow: getFlexGrow,
      width: function width(value) {
        return getWidth(value, columns, gutter);
      }
    };
    return map[property](value);
  };
  /*
   * [1] IE11 doesn't use the correct box-sizing model with the flex-basis
   *     property. The workaround is to set flex-basis to 'auto' and use 'width'
   *     instead.
   */


  return _objectSpread({
    flexBasis: 'auto'
  }, (0, _styles.getResponsiveStyles)({
    breakpoints: breakpoints,
    mapValueToProperty: mapValueToProperty,
    styles: {
      flexGrow: span,
      width: span // [1]

    },
    theme: theme
  }));
}));
exports.GridItemRoot = GridItemRoot;