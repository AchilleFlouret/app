"use strict";

exports.__esModule = true;
exports.NavItemRoot = exports.NavigationRoot = void 0;

var _styledBase = _interopRequireDefault(require("@emotion/styled-base"));

var _isPropValid = _interopRequireDefault(require("@emotion/is-prop-valid"));

var _styles = require("../styles");

var _themes = require("../themes");

var _emotion = require("../utils/emotion");

var _Button = _interopRequireDefault(require("../Button"));

var _constants = require("./constants");

var _themes2 = require("./themes");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var NavigationRoot = (
/*#__PURE__*/
0, _styledBase.default)('nav', {
  shouldForwardProp: function shouldForwardProp(prop) {
    return ['prefix', 'type'].indexOf(prop) === -1 && (0, _isPropValid.default)(prop);
  },
  target: "e1befqft0"
})(function (_ref) {
  var _aligns, _objectSpread2;

  var align = _ref.align,
      prefix = _ref.prefix,
      baseTheme = _ref.theme,
      type = _ref.type;
  var theme = (0, _themes2.navigationTheme)(baseTheme);
  var aligns = (_aligns = {}, _aligns[_constants.ALIGN.start] = 'flex-start', _aligns[_constants.ALIGN.center] = 'center', _aligns[_constants.ALIGN.end] = 'flex-end', _aligns[_constants.ALIGN.justify] = undefined, _aligns);
  return _objectSpread({}, (0, _styles.componentStyleReset)(baseTheme), {
    backgroundColor: theme[prefix + "Nav_backgroundColor" + type],
    borderBottom: theme[prefix + "Nav_border"],
    display: 'flex',
    justifyContent: aligns[align],
    listStyle: 'none',
    margin: 0,
    // prettier-ignore
    padding: theme[prefix + "Nav_paddingVertical"] + " " + theme[prefix + "Nav_paddingHorizontal"]
  }, type === _constants.INTERNAL_TYPE.tabs ? {
    paddingBottom: 0
  } : undefined, (_objectSpread2 = {}, _objectSpread2['& > :not(:first-child)' + _emotion.ignoreSsrWarning] = {
    marginLeft: theme[prefix + "Nav_gutter"]
  }, _objectSpread2));
});
exports.NavigationRoot = NavigationRoot;
var NavItemButton = (
/*#__PURE__*/
0, _styledBase.default)(_Button.default, {
  shouldForwardProp: function shouldForwardProp(prop) {
    return prop === 'as' || ['prefix', 'selected', 'type'].indexOf(prop) === -1;
  },
  target: "e1befqft1"
})(function (_ref2) {
  var align = _ref2.align,
      disabled = _ref2.disabled,
      maxWidth = _ref2.maxWidth,
      prefix = _ref2.prefix,
      selected = _ref2.selected,
      baseTheme = _ref2.theme,
      type = _ref2.type;
  var theme = (0, _themes2.navItemTheme)(baseTheme);
  return _objectSpread({
    backgroundColor: disabled && 'transparent',
    display: 'block',
    '&:hover': {
      color: !disabled && theme[prefix + "NavItem_color" + type + "_hover"]
    }
  }, align === _constants.ALIGN.justify ? {
    flexGrow: 1
  } : {
    maxWidth: maxWidth
  }, selected ? _objectSpread({}, type === _constants.INTERNAL_TYPE.tabs ? {
    position: 'relative',
    '&::before': {
      // prettier-ignore
      backgroundColor: theme[prefix + "NavItem_borderColor" + type + "_selected"],
      bottom: -2,
      content: '""',
      left: -1,
      position: 'absolute',
      right: -1,
      height: 1
    }
  } : {
    borderColor: theme[prefix + "NavItem_borderColor" + type + "_selected"]
  }, {
    '&:hover': {
      backgroundColor: theme[prefix + "NavItem_backgroundColor" + type + "_selected"],
      borderColor: type !== '_tabs' ? theme[prefix + "NavItem_borderColor" + type + "_selected"] : undefined,
      color: theme[prefix + "NavItem_color" + type + "_selected"]
    },
    '&, &:focus': {
      backgroundColor: theme[prefix + "NavItem_backgroundColor" + type + "_selected"],
      color: theme[prefix + "NavItem_color" + type + "_selected"]
    }
  }) : undefined, {
    // Truncate
    '&:active > span > span > span > span > span:focus': {
      outline: 'none'
    },
    // Button's Inner
    '& > span': {
      // Content
      '& > span': {
        // Tooltip & TooltipTrigger & Truncate
        '& > span, & > span > span, & > span > span > span': {
          display: 'block'
        }
      }
    }
  });
});
/*
 * Theming a styled button here (rather than styling a themed button, as we
 * usually do) because we need to filter some props, which breaks the usual
 * pattern.
 */

var NavItemRoot = (0, _themes.themed)(NavItemButton)(function (_ref3) {
  var prefix = _ref3.prefix,
      baseTheme = _ref3.theme,
      type = _ref3.type;

  var theme = _objectSpread({}, (0, _themes2.navItemTheme)(baseTheme), (0, _themes2.navigationTheme)(baseTheme)); // prettier-ignore


  return _objectSpread({
    borderColor_theme_focus: theme[prefix + "NavItem_borderColor" + type + "_focus"],
    boxShadow_focusInner: theme[prefix + "Nav_backgroundColor" + type],
    Button_backgroundColor: theme[prefix + "NavItem_backgroundColor" + type],
    Button_backgroundColor_active: theme[prefix + "NavItem_backgroundColor" + type + "_active"],
    Button_backgroundColor_focus: theme[prefix + "NavItem_backgroundColor" + type + "_focus"],
    Button_backgroundColor_hover: theme[prefix + "NavItem_backgroundColor" + type + "_hover"],
    Button_borderColor: theme[prefix + "NavItem_borderColor" + type],
    Button_borderColor_active: theme[prefix + "NavItem_borderColor" + type + "_active"],
    Button_borderColor_focus: theme[prefix + "NavItem_borderColor" + type + "_focus"],
    Button_borderColor_hover: theme[prefix + "NavItem_borderColor" + type + "_hover"],
    Button_color: theme[prefix + "NavItem_color" + type],
    Button_paddingHorizontal: theme[prefix + "NavItem_paddingHorizontal"],
    ButtonContent_fontSize_small: theme.fontSize_ui,
    ButtonIcon_color: theme[prefix + "NavItemIcon_color"]
  }, type === _constants.INTERNAL_TYPE.none ? {
    color_disabled: theme[prefix + "NavItem_color" + type + "_disabled"]
  } : undefined, type === _constants.INTERNAL_TYPE.tabs ? {
    Button_borderRadius: theme.borderRadius_1 + " " + theme.borderRadius_1 + " 0 0"
  } : undefined);
});
exports.NavItemRoot = NavItemRoot;